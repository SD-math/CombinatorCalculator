# CombinatorCalculator
A package designed to check calculations in combinatory algebras.

## Combinators
The core module, `combinators.py` contains classes `Combinator` and `Atom`. The `Combinator` class governs behaviour of combinator application, which is implemented as `__mul__`. Therefore, if `a` and `b` are combinators, then `a*b` gives `a` applied to `b`.

We can define new atoms, e.g. `x = Atom("x")`, which is a combinator which prints as `"x"` and applies to other terms as if it is a free variable. To define primitives, i.e. atoms with a reduction rule, we include an function to express the reduction rule. For example, below we introduce the so-called "mockingbird" combinator. We can quickly check what a combinator does by applying it to integers. For these purposes, an integer `n` will be converted to `Atom("<{}>".format(n))`.
```
>>> M = Atom("M", lambda x: x*x)
>>> M*0
<0><0>
```
Indeed, we can produce the well-known infinite loop:
```
>>> M*M
...
RecursionError: maximum recursion depth exceeded
```

## SK basis
In the module `SK_basis.py`, the usual primitive `S` and `K` are built in, as are some combinators which are generated by `S` and `K`. 

```
>>> from SK_basis import *
>>> S*0*1*2 # try out S
<0><2>(<1><2>)
>>> K*0*1 # try out K
<0>
>>> K*identity*0*1 # try out K*identity
<1>
>>> B # the B combinator is built in - otherwise known as the bluebird
S(KS)(S(KK)(SKK))
>>> B*0*1*2 # try out the bluebird
<0>(<1><2>)
>>> bluebird(3)*0*1*2*3*4 # there are a whole family of bluebirds, with B = bluebird(1)
<0>(<1><2><3><4>)
>>> projection(1, 0)*0 # projection combinators are built in
<0>
>>> projection(2,0)*0*1
<0>
>>> projection(2,1)*0*1
<1>
>>> projection(5,3)*0*1*2*3*4
<3>
>>> projection(5,3)
K(K(K(S(KK)(SKK))))
```
We can construct the mockingbird as `S*identity*identity`:
```
>>> S*identity*identity*0
<0><0>
```

Sch&ouml;nfinkel's combinator `C` is built in. We can construct the famous `Y` combinator (otherwise known as the "fixed point combinator"):
```
>>> C
S(S(K(S(KS)K))S)(KK)
>>> C*0*1*2 # try out the C combinator
<0><2><1>
>>> M = S*identity*identity # create the mockingbird
>>> Y = B*M*(C*B*M) # create the Y combinator
```
However, the `Y` combinator gets us into an infinite loop if we try to apply it, but it is an intentional infinite loop:
```
>>> Y*0
...
RecursionError: maximum recursion depth exceeded while calling a Python object

```
We can deduce a closed term to represent any term, by giving the expression for the term in terms of the variables and using the  `curry` function to "curry out" all of the variables:
```
>>> x = Atom("x")
>>> y = Atom("y")
>>> z = Atom("z")
>>> curry(x*z*y, x, y, z)
S(S(KS)(S(KK)(S(KS)(S(S(KS)(S(KK)(SKK)))(K(SKK))))))(K(S(KK)(SKK)))
```
We can even check that this expression works, because it is a combinator:
```
>>> curry(x*z*y, x, y, z)*x*y*z
xzy
```
Clearly `curry` does not produce the shortest possible representation. The term `curry(x*z*y, x, y, z)` serves the same purpose as the much simpler combinator `C`.

In a couple of stages, we can use currying to derive the `Y` combinator. However, some care must be taken, and it helps to also know how currying works mathematically. The `Y` combinator ought to be such that, for any `f`, `Y*f` is `t*t`, where, for any `x`, `t*x=f*(x*x)`. We can curry `x` out of `t`:
```
>>> f = Atom("f")
>>> x = Atom("x")
>>> t = curry(f*(x*x), x)
>>> t
S(Kf)(S(SKK)(SKK))
```
However, we cannot simply rush in and calculate `Y = curry(t*t, f)`. This would end up in an infinite loop, as `t*t` also ends up in an infinite loop (intentionally!). But, we can curry `f` out of `t`, and from there we can derive `Y`. As before, we cannot compute `Y*f`:
```
>>> u = curry(t, f)
>>> u
S(S(KS)(S(KK)(SKK)))(K(S(SKK)(SKK)))
>>> Y = S*u*u
>>> Y
S(S(S(KS)(S(KK)(SKK)))(K(S(SKK)(SKK))))(S(S(KS)(S(KK)(SKK)))(K(S(SKK)(SKK))))
>>> Y*f
...
RecursionError: maximum recursion depth exceeded
```
