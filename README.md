# CombinatorCalculator
A package designed to check calculations in combinatory algebras.

## Combinators
The core module, `combinators.py` contains classes `Combinator` and `Atom`. The `Combinator` class governs behaviour of combinator application, which is implemented as `__mul__`. Therefore, if `a` and `b` are combinators, then `a*b` gives `a` applied to `b`.

We can define new atoms, e.g. `x = Atom("x")`, which is a combinator which prints as `"x"` and applies to other terms as if it is a free variable. To define primitives, i.e. atoms with a reduction rule, we include an function to express the reduction rule. For example, below we introduce the so-called "mockingbird" combinator. We can quickly check what a combinator does by applying it to integers. For these purposes, an integer `n` will be converted to `Atom(n)`, which basically turns the integer into a free variable &mdash; so only use single digit integers, to avoid confusion.
```
>>> M = Atom("M", lambda x: x*x)
>>> M*0
00
```
Indeed, we can produce the well-known infinite loop:
```
>>> M*M
...
RecursionError: maximum recursion depth exceeded
```

## SK basis
In the module `SK_basis.py`, the usual primitive `S` and `K` are built in, as are some combinators which are generated by `S` and `K`. 

```
>>> from SK_basis import *
>>> S*0*1*2 # try out S
02(12)
>>> K*0*1 # try out K
0
>>> K*identity*0*1 # try out K*identity
1
>>> B # the B combinator is built in - otherwise known as the bluebird
S(KS)(S(KK)(SKK))
>>> B*0*1*2 # try out the bluebird
0(12)
>>> bluebird(3)*0*1*2*3*4 # there are a whole family of bluebirds, with B = bluebird(1)
0(1234)
>>> projection(1, 0)*0 # projection combinators are built in
0
>>> projection(2,0)*0*1
0
>>> projection(2,1)*0*1
1
>>> projection(5,3)*0*1*2*3*4
3
>>> projection(5,3)
K(K(K(S(KK)(SKK))))
```
We can construct the mockingbird as `S*identity*identity`:
```
>>> S*identity*identity*0
00
```

Sch&ouml;nfinkel's combinator `C` is built in. We can construct the famous `Y` combinator (otherwise known as the "fixed point combinator"):
```
>>> C
S(S(K(S(KS)K))S)(KK)
>>> C*0*1*2 # try out the C combinator
021
>>> M = S*identity*identity # create the mockingbird
>>> Y = B*M*(C*B*M) # create the Y combinator
```
However, the `Y` combinator gets us into an infinite loop if we try to apply it, but it is an intentional infinite loop:
```
>>> Y*0
...
RecursionError: maximum recursion depth exceeded while calling a Python object

```
We can deduce a closed term to represent any term, by giving the expression for the term in terms of the variables and using the  `curry` function to "curry out" all of the variables:
```
>>> x = Atom("x")
>>> y = Atom("y")
>>> z = Atom("z")
>>> curry(x*z*y, x, y, z)
S(S(KS)(S(KK)S))(KK)
```
We can even check that this expression works, because it is a combinator:
```
>>> curry(x*z*y, x, y, z)*x*y*z
xzy
```
The term `curry(x*z*y, x, y, z)` serves the same purpose as the `C` combinator.

In a couple of stages, we can use currying to derive the `Y` combinator. However, some care must be taken, and it helps to also know how currying works mathematically. The `Y` combinator ought to be such that, for any `f`, `Y*f` is `t*t`, where, for any `x`, `t*x=f*(x*x)`. We can curry `x` out of `t`:
```
>>> f = Atom("f")
>>> x = Atom("x")
>>> t = curry(f*(x*x), x)
>>> t
S(Kf)(S(SKK)(SKK))
```
However, we cannot simply rush in and calculate `Y = curry(t*t, f)`. This would end up in an infinite loop, as `t*t` also ends up in an infinite loop (intentionally!). But, we can curry `f` out of `t`, and from there we can derive `Y`. As before, we cannot compute `Y*f`:
```
>>> u = curry(t, f)
>>> u
S(S(KS)K)(K(S(SKK)(SKK)))
>>> Y = S*u*u
>>> Y
S(S(S(KS)K)(K(S(SKK)(SKK))))(S(S(KS)K)(K(S(SKK)(SKK))))
>>> Y*f
...
RecursionError: maximum recursion depth exceeded
```

For a bit of fun, let's use the calculator to prove that there is a one-point basis `{X}`. 
```
>>> X = curry(x*S*K, x)
>>> X
S(S(SKK)(KS))(KK)
>>> X*(X*(X*X))
K
>>> X*K
S
```
Another solution is:
```
>>> XX = curry(x*K*S*K, x)
>>> XX
S(S(S(SKK)(KK))(KS))(KK)
>>> XX*XX*XX
K
>>> XX*(XX*XX)
S
```